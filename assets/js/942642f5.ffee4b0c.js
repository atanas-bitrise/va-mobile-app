"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[3897],{32887:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var a=n(58168),i=(n(96540),n(15680));n(41873);const s={},o="OpenAPI Documentation",r={unversionedId:"Engineering/BackEnd/Architecture/OpenAPIDocumentation",id:"Engineering/BackEnd/Architecture/OpenAPIDocumentation",title:"OpenAPI Documentation",description:"OpenAPI Creation and Artifact Generation",source:"@site/docs/Engineering/BackEnd/Architecture/OpenAPIDocumentation.md",sourceDirName:"Engineering/BackEnd/Architecture",slug:"/Engineering/BackEnd/Architecture/OpenAPIDocumentation",permalink:"/va-mobile-app/docs/Engineering/BackEnd/Architecture/OpenAPIDocumentation",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Models",permalink:"/va-mobile-app/docs/Engineering/BackEnd/Architecture/ModelsAndSerializers"},next:{title:"Parallel Calls",permalink:"/va-mobile-app/docs/Engineering/BackEnd/Architecture/ParallelCalls"}},l={},c=[{value:"OpenAPI Creation and Artifact Generation",id:"openapi-creation-and-artifact-generation",level:2},{value:"Setup",id:"setup",level:2},{value:"Using OpenAPI in RSpec",id:"using-openapi-in-rspec",level:2},{value:"Limitations",id:"limitations",level:2},{value:"Best Practices",id:"best-practices",level:2}],d={toc:c},p="wrapper";function u(e){let{components:t,...n}=e;return(0,i.yg)(p,(0,a.A)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"openapi-documentation"},"OpenAPI Documentation"),(0,i.yg)("h2",{id:"openapi-creation-and-artifact-generation"},"OpenAPI Creation and Artifact Generation"),(0,i.yg)("p",null,"We document our API endpoints using ",(0,i.yg)("a",{parentName:"p",href:"https://swagger.io/specification/"},"OpenAPI3"),". The documentation is recorded in a group of yaml files, which are converted to ",(0,i.yg)("a",{parentName:"p",href:"/va-mobile-app/docs/Engineering/BackEnd/API/"},"HTML")," and JSON via the ",(0,i.yg)("inlineCode",{parentName:"p"},"modules/mobile/docs/generate_static_docs.sh")," script. Developers must run that script each time they change the yaml to ensure that our documentation is up to date."),(0,i.yg)("h2",{id:"setup"},"Setup"),(0,i.yg)("p",null,"Developers will need to install ",(0,i.yg)("a",{parentName:"p",href:"https://redocly.com/docs/cli/installation#install-globally"},"redocly")," in order to run the ",(0,i.yg)("inlineCode",{parentName:"p"},"generate_static_docs")," script."),(0,i.yg)("h2",{id:"using-openapi-in-rspec"},"Using OpenAPI in RSpec"),(0,i.yg)("p",null,"The backend team uses the ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/willnet/committee-rails"},"committee-rails gem")," to tie our documentation and specs together. This gem should be used in request specs to validate requests and responses against the JSON file generated by the ",(0,i.yg)("inlineCode",{parentName:"p"},"generate_static_docs")," script. To add it to a request spec, simply call the method ",(0,i.yg)("inlineCode",{parentName:"p"},"assert_schema_conform(expected_status)"),". This will use the uri path from the ",(0,i.yg)("inlineCode",{parentName:"p"},"request")," object and the expected status (e.g., 200) to look up which schema the response should match and validate the ",(0,i.yg)("inlineCode",{parentName:"p"},"response.body")," against it."),(0,i.yg)("h2",{id:"limitations"},"Limitations"),(0,i.yg)("p",null,"Our schema tests are only as good as the data we're testing against. These tests run against VCR cassettes we've either recorded or been given. These cassettes will not necessarily cover all cases. It's also possible for cassettes to become out of date, which can cause drift between our specs/OpenAPI documentation and reality."),(0,i.yg)("p",null,"Schema tests are also only as good as the schema they're testing against. Schema should be written as strictly as possible. That means indicating when properties are required or nullable, when additional properties are not permitted in objects, indicating string formats, and specifying which strings are possible via the enum type. Greater specificity results in better documentation."),(0,i.yg)("h2",{id:"best-practices"},"Best Practices"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"use ",(0,i.yg)("a",{parentName:"li",href:"/va-mobile-app/docs/Engineering/BackEnd/Architecture/ModelsAndSerializers"},"models and serializers")," to lock down the schema"),(0,i.yg)("li",{parentName:"ul"},"use all VCR cassettes available to ensure broad test coverage"),(0,i.yg)("li",{parentName:"ul"},"only validate the schema once per unique case. In other words, if you need to run several tests with the same data setup and you expect the same response each time, there's no need to validate the schema each time."),(0,i.yg)("li",{parentName:"ul"},"use ",(0,i.yg)("inlineCode",{parentName:"li"},"nullable: true")," when you know an attribute may be null. This should also be reflected in the model."),(0,i.yg)("li",{parentName:"ul"},"use ",(0,i.yg)("inlineCode",{parentName:"li"},"additionalProperties: false")," on all objects. Additional properties should be prevented by the model and serializer.")))}u.isMDXComponent=!0}}]);